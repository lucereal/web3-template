import * as fs from "fs";
import * as path from "path";
import { Interface } from "@ethersproject/abi";
import { readABI, ABIData } from "./utils/abi-reader";

interface EnumInfo {
  name: string;
  values: Record<string, number>;
}

function extractEnumsFromABI(abi: any[]): EnumInfo[] {
  const enums: EnumInfo[] = [];
  
  // Look for events and functions that might indicate enum usage
  // For now, we'll define known enums based on the contract structure
  // In a more advanced version, we could parse the contract source or use type info
  
  // Check if the contract has ResourceType-related functions
  const hasResourceTypeUsage = abi.some(item => 
    item.type === 'function' && 
    item.inputs?.some((input: any) => input.name?.includes('resourceType'))
  );
  
  if (hasResourceTypeUsage) {
    enums.push({
      name: 'ResourceType',
      values: {
        URL: 0,
        IPFS: 1
      }
    });
  }
  
  return enums;
}

function generateEnumsCode(enums: EnumInfo[]): string {
  if (enums.length === 0) {
    return '// No enums detected in this contract';
  }
  
  return enums.map(enumInfo => {
    const enumEntries = Object.entries(enumInfo.values)
      .map(([key, value]) => `  ${key} = ${value}`)
      .join(',\n');
    
    return `// ${enumInfo.name} enum (matches contract)
export enum ${enumInfo.name} {
${enumEntries}
}`;
  }).join('\n\n');
}

function generateGasEstimates(functions: string[]): Record<string, number> {
  const gasEstimates: Record<string, number> = {};
  
  // Smart gas estimation based on function complexity
  functions.forEach(funcSig => {
    const funcName = funcSig.split('(')[0];
    
    // Skip constants (they don't consume gas)
    if (funcName === 'VERSION') {
      return; // Constants are compile-time, no gas needed
    }
    
    // Categorize functions by complexity
    if (funcName.includes('create') || funcName.includes('initialize')) {
      gasEstimates[funcName] = 500000; // Complex operations
    } else if (funcName.includes('buy') || funcName.includes('purchase')) {
      gasEstimates[funcName] = 300000; // Moderate operations
    } else if (funcName.includes('withdraw') || funcName.includes('transfer')) {
      gasEstimates[funcName] = 100000; // Simple operations
    } else if (funcName.includes('emergency') || funcName.includes('admin')) {
      gasEstimates[funcName] = 150000; // Admin operations
    } else if (funcName.includes('get') || funcName.includes('view')) {
      // Skip view functions - they don't need gas estimates
    } else {
      gasEstimates[funcName] = 200000; // Default estimate
    }
  });
  
  return gasEstimates;
}

function generateConstants(data: ABIData) {
  const { abi, artifact } = data;
  const iface = new Interface(abi);
  
  // Extract events
  const events = Object.keys(iface.events);
  const eventNames = events.reduce((acc, eventName) => {
    acc[eventName] = eventName;
    return acc;
  }, {} as Record<string, string>);
  
  // Extract enums dynamically from ABI
  const enums = extractEnumsFromABI(abi);
  
  // Generate topic hashes
  const eventTopics = events.reduce((acc, eventName) => {
    acc[eventName] = iface.getEventTopic(eventName);
    return acc;
  }, {} as Record<string, string>);
  
  // Extract function signatures for gas estimation
  const functions = Object.keys(iface.functions);
  const gasLimits = generateGasEstimates(functions);
  
  // Extract contract metadata
  const contractName = artifact.contractName || 'AccessContract';
  const compilerVersion = artifact.compiler?.version || '0.8.24';
  
  // Check for VERSION constant (required)
  const hasVersionConstant = functions.some(func => func.startsWith('VERSION('));
  
  if (!hasVersionConstant) {
    throw new Error(
      'VERSION constant not found in contract. Please add "string public constant VERSION = \'x.x.x\';" to your contract.'
    );
  }
  
  const enumsCode = generateEnumsCode(enums);
  
  const content = `/**
 * Contract constants and configurations
 * Auto-generated by generate-constants.ts
 * Generated on: ${new Date().toISOString()}
 */

export const CONTRACT_NAME = '${contractName}';
// Contract version available via VERSION constant
export const CONTRACT_VERSION = 'dynamic'; // Use getContractVersion() for runtime value
export const COMPILER_VERSION = '${compilerVersion}';

${enumsCode}

// Event names for filtering
export const EVENT_NAMES = ${JSON.stringify(eventNames, null, 2)} as const;

// Event topic hashes for efficient filtering
export const EVENT_TOPICS = ${JSON.stringify(eventTopics, null, 2)} as const;

// Gas limits (estimated based on function complexity)
export const GAS_LIMITS = ${JSON.stringify(gasLimits, null, 2)} as const;

// Type helpers
export type EventName = keyof typeof EVENT_NAMES;
export type EventTopic = typeof EVENT_TOPICS[EventName];

// Common constants
export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
export const MAX_UINT256 = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

/**
 * Get contract version from the VERSION constant
 * Usage: const version = await getContractVersion(contractInstance);
 */
export async function getContractVersion(contract: any): Promise<string> {
  try {
    if (typeof contract.VERSION !== 'function') {
      throw new Error('VERSION constant not found on contract instance');
    }
    return await contract.VERSION();
  } catch (error) {
    console.error('Failed to get contract version:', error);
    throw error;
  }
}`;
  
  return content;
}

async function saveConstants(content: string) {
  const constantsDir = path.join(process.cwd(), "src", "constants");
  const constantsPath = path.join(constantsDir, "contract.ts");
  
  if (!fs.existsSync(constantsDir)) {
    fs.mkdirSync(constantsDir, { recursive: true });
    console.log("üìÅ Created directory:", constantsDir);
  }
  
  fs.writeFileSync(constantsPath, content);
  console.log("üíæ Constants saved to:", constantsPath);
}

async function main() {
  try {
    console.log("üîÑ Generating contract constants...");
    
    const data = await readABI();
    const content = generateConstants(data);
    await saveConstants(content);
    
    console.log("‚úÖ Constants generated successfully!");
    console.log("\nüéØ Generated:");
    console.log("  - Contract metadata");
    console.log("  - Dynamic enum extraction");
    console.log("  - Event names and topic hashes");
    console.log("  - Smart gas limit estimates");
    console.log("  - Common blockchain constants");
    
  } catch (error: any) {
    console.error("‚ùå Generation failed:", error.message);
    process.exitCode = 1;
  }
}

main().catch((error) => {
  console.error("‚ùå Script failed:", error);
  process.exitCode = 1;
});
