import * as fs from "fs";
import * as path from "path";
import { Interface } from "@ethersproject/abi";

async function readABI() {
  const abiPath = path.join(process.cwd(), "src", "abi", "AccessContract.json");
  
  if (!fs.existsSync(abiPath)) {
    throw new Error(`ABI not found: ${abiPath}. Run update-from-blockchain.ts first.`);
  }
  
  const abi = JSON.parse(fs.readFileSync(abiPath, "utf8"));
  console.log(`üìÅ Read ABI with ${abi.length} entries`);
  
  return abi;
}

function generateConstants(abi: any[]) {
  const iface = new Interface(abi);
  
  // Extract events
  const events = Object.keys(iface.events);
  const eventNames = events.reduce((acc, eventName) => {
    acc[eventName] = eventName;
    return acc;
  }, {} as Record<string, string>);
  
  // Extract enums from ABI (look for specific types)
  const resourceTypeEnum = {
    URL: 0,
    IPFS: 1
  };
  
  // Generate topic hashes
  const eventTopics = events.reduce((acc, eventName) => {
    acc[eventName] = iface.getEventTopic(eventName);
    return acc;
  }, {} as Record<string, string>);
  
  // Basic gas estimates
  const gasLimits = {
    createResource: 500000,
    buyAccess: 300000,
    withdraw: 100000,
    emergencyDeactivateResource: 150000
  };
  
  const content = `/**
 * Contract constants and configurations
 * Auto-generated by generate-constants.ts
 */

export const CONTRACT_NAME = 'AccessContract';
export const CONTRACT_VERSION = '1.0.1';
export const COMPILER_VERSION = '0.8.24';

// Resource Types enum (matches contract)
export enum ResourceType {
  URL = 0,
  IPFS = 1
}

// Event names for filtering
export const EVENT_NAMES = ${JSON.stringify(eventNames, null, 2)} as const;

// Event topic hashes
export const EVENT_TOPICS = ${JSON.stringify(eventTopics, null, 2)} as const;

// Gas limits (estimated)
export const GAS_LIMITS = ${JSON.stringify(gasLimits, null, 2)} as const;

export type EventName = typeof EVENT_NAMES[keyof typeof EVENT_NAMES];
`;
  
  return content;
}

async function saveConstants(content: string) {
  const constantsDir = path.join(process.cwd(), "src", "constants");
  const constantsPath = path.join(constantsDir, "contract.ts");
  
  if (!fs.existsSync(constantsDir)) {
    fs.mkdirSync(constantsDir, { recursive: true });
    console.log("üìÅ Created directory:", constantsDir);
  }
  
  fs.writeFileSync(constantsPath, content);
  console.log("üíæ Constants saved to:", constantsPath);
}

async function main() {
  try {
    console.log("üîÑ Generating contract constants...");
    
    const abi = await readABI();
    const content = generateConstants(abi);
    await saveConstants(content);
    
    console.log("‚úÖ Constants generated successfully!");
    console.log("\nüéØ Generated:");
    console.log("  - Contract metadata");
    console.log("  - ResourceType enum");
    console.log("  - Event names");
    console.log("  - Event topic hashes");
    console.log("  - Gas limit estimates");
    
  } catch (error: any) {
    console.error("‚ùå Generation failed:", error.message);
    process.exitCode = 1;
  }
}

main().catch((error) => {
  console.error("‚ùå Script failed:", error);
  process.exitCode = 1;
});
