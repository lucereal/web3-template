import * as fs from "fs";
import * as path from "path";
import { Interface } from "@ethersproject/abi";

async function readABI() {
  const abiPath = path.join(process.cwd(), "src", "abi", "AccessContract.json");
  
  if (!fs.existsSync(abiPath)) {
    throw new Error(`ABI not found: ${abiPath}. Run update-from-blockchain.ts first.`);
  }
  
  const abi = JSON.parse(fs.readFileSync(abiPath, "utf8"));
  console.log(`📁 Read ABI with ${abi.length} entries`);
  
  return abi;
}

function generateTypes(abi: any[]) {
  const iface = new Interface(abi);
  const events = Object.keys(iface.events);
  
  // Generate event interfaces
  const eventInterfaces = events.map(eventName => {
    const event = iface.events[eventName];
    const inputs = event.inputs || [];
    
    const properties = inputs.map(input => {
      let type = input.type;
      
      // Convert Solidity types to TypeScript
      if (type === 'uint256' || type.startsWith('uint')) {
        type = 'bigint';
      } else if (type === 'address') {
        type = 'string';
      } else if (type === 'bool') {
        type = 'boolean';
      } else if (type === 'string') {
        type = 'string';
      } else if (type.startsWith('uint8') && input.name === 'resourceType') {
        type = 'ResourceType';
      }
      
      return `  ${input.name}: ${type};`;
    }).join('\n');
    
    return `export interface ${eventName}Event {
  name: '${eventName}';
${properties}
}`;
  }).join('\n\n');
  
  // Generate struct types
  const structTypes = `export interface Resource {
  owner: string;
  name: string;
  description: string;
  cid: string;
  url: string;
  serviceId: string;
  price: bigint;
  isActive: boolean;
  resourceType: ResourceType;
  createdAt: bigint;
}

export interface Access {
  amountPaid: bigint;
  purchasedAt: bigint;
}`;
  
  const content = `/**
 * Contract type definitions
 * Auto-generated by generate-types.ts
 */

import { ResourceType } from "../constants/contract";

// Contract struct types
${structTypes}

// Event interfaces
${eventInterfaces}

// Union type for all events
export type AccessContractEvent = ${events.map(name => `${name}Event`).join(' | ')};

// Generic log type
export interface RawLog {
  topics: string[];
  data: string;
  address?: string;
  blockNumber?: number;
  transactionHash?: string;
  transactionIndex?: number;
  blockHash?: string;
  logIndex?: number;
}
`;
  
  return content;
}

async function saveTypes(content: string) {
  const typesDir = path.join(process.cwd(), "src", "types");
  const typesPath = path.join(typesDir, "AccessContract.ts");
  
  if (!fs.existsSync(typesDir)) {
    fs.mkdirSync(typesDir, { recursive: true });
    console.log("📁 Created directory:", typesDir);
  }
  
  fs.writeFileSync(typesPath, content);
  console.log("💾 Types saved to:", typesPath);
}

async function main() {
  try {
    console.log("🔄 Generating contract types...");
    
    const abi = await readABI();
    const content = generateTypes(abi);
    await saveTypes(content);
    
    console.log("✅ Contract types generated successfully!");
    console.log("\n🎯 Generated:");
    console.log("  - Resource and Access struct types");
    console.log("  - Event interfaces for each event");
    console.log("  - Union type for all events");
    console.log("  - RawLog interface");
    
  } catch (error: any) {
    console.error("❌ Generation failed:", error.message);
    process.exitCode = 1;
  }
}

main().catch((error) => {
  console.error("❌ Script failed:", error);
  process.exitCode = 1;
});
