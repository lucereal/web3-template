import * as fs from "fs";
import * as path from "path";
import { Interface } from "@ethersproject/abi";
import { readABIOnly } from "./utils/abi-reader";

function generateTypes(abi: any[]) {
  const iface = new Interface(abi);
  const events = Object.keys(iface.events);
  
  // Generate event interfaces
  const eventInterfaces = events.map(eventName => {
    // Extract clean event name without parameters
    const cleanEventName = eventName.split('(')[0];
    const event = iface.events[eventName];
    const inputs = event.inputs || [];
    
    const properties = inputs.map(input => {
      let type = input.type;
      let propertyName = input.name;
      
      // Handle naming conflicts with the event 'name' property
      if (propertyName === 'name') {
        propertyName = 'resourceName'; // Rename to avoid conflict
      }
      
      // Convert Solidity types to TypeScript
      if (type === 'uint256' || type.startsWith('uint')) {
        type = 'bigint';
      } else if (type === 'address') {
        type = 'string';
      } else if (type === 'bool') {
        type = 'boolean';
      } else if (type === 'string') {
        type = 'string';
      } else if (type.startsWith('uint8') && input.name === 'resourceType') {
        type = 'ResourceType';
      }
      
      return `  ${propertyName}: ${type};`;
    }).join('\n');
    
    return `export interface ${cleanEventName}Event {
  name: '${cleanEventName}';
${properties}
}`;
  }).join('\n\n');
  
  // Generate struct types
  const structTypes = `export interface Resource {
  owner: string;
  name: string;
  description: string;
  cid: string;
  url: string;
  serviceId: string;
  price: bigint;
  isActive: boolean;
  resourceType: ResourceType;
  createdAt: bigint;
}

export interface Access {
  amountPaid: bigint;
  purchasedAt: bigint;
}`;
  
  const content = `/**
 * Contract type definitions
 * Auto-generated by generate-types.ts
 */

import { ResourceType } from "../constants/contract";

// Contract struct types
${structTypes}

// Event interfaces
${eventInterfaces}

// Union type for all events
export type AccessContractEvent = ${events.map(name => `${name.split('(')[0]}Event`).join(' | ')};

// Generic log type
export interface RawLog {
  topics: string[];
  data: string;
  address?: string;
  blockNumber?: number;
  transactionHash?: string;
  transactionIndex?: number;
  blockHash?: string;
  logIndex?: number;
}
`;
  
  return content;
}

async function saveTypes(content: string) {
  const typesDir = path.join(process.cwd(), "src", "types");
  const typesPath = path.join(typesDir, "AccessContract.ts");
  
  if (!fs.existsSync(typesDir)) {
    fs.mkdirSync(typesDir, { recursive: true });
    console.log("📁 Created directory:", typesDir);
  }
  
  fs.writeFileSync(typesPath, content);
  console.log("💾 Types saved to:", typesPath);
}

async function main() {
  try {
    console.log("🔄 Generating contract types...");
    
    const abi = await readABIOnly();
    const content = generateTypes(abi);
    await saveTypes(content);
    
    console.log("✅ Contract types generated successfully!");
    console.log("\n🎯 Generated:");
    console.log("  - Resource and Access struct types");
    console.log("  - Event interfaces for each event");
    console.log("  - Union type for all events");
    console.log("  - RawLog interface");
    
  } catch (error: any) {
    console.error("❌ Generation failed:", error.message);
    process.exitCode = 1;
  }
}

main().catch((error) => {
  console.error("❌ Script failed:", error);
  process.exitCode = 1;
});
