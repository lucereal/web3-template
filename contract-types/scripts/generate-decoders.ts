import * as fs from "fs";
import * as path from "path";
import { Interface } from "@ethersproject/abi";
import { readABIOnly } from "./utils/abi-reader";

function generateDecoders(abi: any[]) {
  const iface = new Interface(abi);
  const events = Object.keys(iface.events);
  
  // Create mapping of event names to their parameter structure
  const eventMappings: Record<string, any> = {};
  
  events.forEach(eventName => {
    const cleanEventName = eventName.split('(')[0];
    const event = iface.getEvent(eventName);
    eventMappings[cleanEventName] = event;
  });
  
  const decoderFunctions = events.map(eventName => {
    // Extract just the event name without parameters for function name
    const cleanEventName = eventName.split('(')[0];
    const functionName = `decode${cleanEventName}`;
    const event = eventMappings[cleanEventName];
    
    // Generate the property mapping based on event inputs
    const propertyMappings = event.inputs.map((input: any, index: number) => {
      // Handle property name conflicts (e.g., 'name' parameter conflicts with event name)
      let propertyName = input.name;
      if (cleanEventName === 'ResourceCreated' && input.name === 'name') {
        propertyName = 'resourceName';  // Rename to avoid conflict
      }
      
      return `    ${propertyName}: parsed.args[${index}]`;
    }).join(',\n');
    
    return `export function ${functionName}(log: Log): ${cleanEventName}Event {
  try {
    const iface = new Interface(ABI);
    const parsed = iface.parseLog(log);
    
    if (parsed.name !== '${cleanEventName}') {
      throw new Error(\`Expected ${cleanEventName} event, got \${parsed.name}\`);
    }
    
    return {
      name: '${cleanEventName}' as const,
${propertyMappings}
    };
  } catch (error: any) {
    throw new Error(\`Failed to decode ${cleanEventName}: \${error.message}\`);
  }
}`;
  }).join('\n\n');
  
  const content = `/**
 * Event decoder functions
 * Auto-generated by generate-decoders.ts
 */

import { Interface } from "@ethersproject/abi";
import ABI from "../abi/AccessContract.json";
import type {
  AccessPurchasedEvent,
  InitializedEvent,
  OwnershipTransferredEvent,
  ResourceCreatedEvent,
  WithdrawalEvent,
  AccessContractEvent
} from "../types/AccessContract";

// Generic log interface
export interface Log {
  topics: string[];
  data: string;
}

// Generic decoder function
export function decodeEvent(log: Log) {
  const iface = new Interface(ABI);
  return iface.parseLog(log);
}

// Specific event decoders
${decoderFunctions}

// Decode any event and return typed result
export function decodeAccessContractEvent(log: Log): AccessContractEvent {
  const iface = new Interface(ABI);
  const parsed = iface.parseLog(log);
  
  switch (parsed.name) {
${events.map(eventName => {
    const cleanEventName = eventName.split('(')[0];
    return `    case '${cleanEventName}':
      return decode${cleanEventName}(log);`;
  }).join('\n')}
    default:
      throw new Error(\`Unknown event: \${parsed.name}\`);
  }
}
`;
  
  return content;
}

async function saveDecoders(content: string) {
  const utilsDir = path.join(process.cwd(), "src", "utils");
  const decodersPath = path.join(utilsDir, "eventDecoding.ts");
  
  if (!fs.existsSync(utilsDir)) {
    fs.mkdirSync(utilsDir, { recursive: true });
    console.log("üìÅ Created directory:", utilsDir);
  }
  
  fs.writeFileSync(decodersPath, content);
  console.log("üíæ Decoders saved to:", decodersPath);
}

async function main() {
  try {
    console.log("üîÑ Generating event decoders...");
    
    const abi = await readABIOnly();
    const content = generateDecoders(abi);
    await saveDecoders(content);
    
    console.log("‚úÖ Event decoders generated successfully!");
    console.log("\nüéØ Generated:");
    console.log("  - Generic decodeEvent function");
    console.log("  - Specific decoder for each event");
    console.log("  - Universal decodeAccessContractEvent function");
    
  } catch (error: any) {
    console.error("‚ùå Generation failed:", error.message);
    process.exitCode = 1;
  }
}

main().catch((error) => {
  console.error("‚ùå Script failed:", error);
  process.exitCode = 1;
});
